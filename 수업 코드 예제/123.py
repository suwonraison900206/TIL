def backtrack(a, k, N, s):
    if s > 4: return      # 가지치기
    # 현재까지 만들어진 부분집합의 원소들의 합이 10보다 크면 종료

    if k == N:         # N번째 단계까지 왔을 때
        if s == 3:    # 부분집합의 합이 0 일 경우
            return a
    else:
        a[k] = 0                         # k 번째 원소 선택 안하는 경우
        backtrack(a, k + 1, N, s)    # k  번째 원소를 선택하지 않았으므로 s 에 해당원소 더하지 않고 다음 단계 호출
        if s+S[k] <= 10:               # k 번째 원소를 더한 합이 10 보다 작거나 같을 경우에만 (가지 치기)
            a[k] = 1                     # k 번째 원소 선택
            backtrack(a, k + 1, N, s + S[k])    # k 번째 원소를 선택했으므로 s 에 k 번째 원소를 더하고 다음 단계 호출
list_k = []
a = [0] * 5
S = [1, 1, 1, 1, 1]
backtrack(a, 0, 5, 0)


#
# 1,2,3,4,5,6,7,8,9,10
# 집합의 선택 여부 판별을 위한
# a = [0,0,0,0,0,0,0,0,0,0]
#
# 선택을 한것은 1, 안한것은 0으로 처리해서 구분
#
# k 는 현재 몇 번째 원소를 건드리고 있는가 체크
# n 은 k가 원소 갯수인 10에 다다르면 멈추도록 넣는 숫자
# s는 만들어진 조합을 매번 더하기보다 그때그때 더해서 누적해가면 연산 횟수가 줄어든다고 하심.
#
# 그래서 처음 backt 함수를 시작할때
# backt(a, 0, 10, 0)
# 으로 시작
# k = 0 부터 k+1로 재귀하면서 n=10 이 될 때까지 함수 작동
# s는 그때그때 원소 합 판별용(시작은 0)
